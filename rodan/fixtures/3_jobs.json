[{"fields": {"category": "Binarization", "description": "\"**abutaleb_threshold** (``Choice`` [dense|rle] *storage format*)\n\nCreates a binary image by using the Abutaleb locally-adaptive\nthresholding algorithm.\n\n*storage_format* (optional)\n  specifies the compression type for the result:\n\n  DENSE (0)\n    no compression\n  RLE (1)\n    run-length encoding compression\"", "settings": "[{\"default\": 0, \"has_default\": false, \"type\": \"choice\", \"name\": \"storage format\", \"choices\": [\"dense\", \"rle\"]}]", "author": null, "enabled": true, "job_name": "gamera.plugins.threshold.abutaleb_threshold", "interactive": false}, "model": "rodan.job", "pk": "00f6ad01f40c420694a39d63c2a9451d"}, {"fields": {"category": "Conversion", "description": "\"**to_onebit** ()\n\nConverts the given image to a ONEBIT image. First the image is converted\nand then the otsu_threshold_ algorithm is applied.\nFor other ways to convert to ONEBIT images, see the Binarization_ category.\n\nConverting an image to one of the same type performs a copy operation.\n\n.. _otsu_threshold: binarization.html#otsu-threshold\n.. _Binarization: binarization.html\"", "settings": "[]", "author": null, "enabled": true, "job_name": "gamera.plugins.image_conversion.to_onebit", "interactive": false}, "model": "rodan.job", "pk": "01f0d3b1d75d4cbb876899c2ced806cd"}, {"fields": {"category": "Border Removal", "description": "\"**med_filter** (int *region size* = 5)\n\nReturns the regional intermediate value of an image as a FLOAT.\n\n*region_size*\n  The size of the region within which to calculate the intermediate pixel value.\"", "settings": "[{\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region size\", \"type\": \"int\"}]", "author": "Yue Phyllis Ouyang and John Ashley Burgoyne", "enabled": true, "job_name": "gamera.toolkits.border_removal.plugins.border_removal.med_filter", "interactive": false}, "model": "rodan.job", "pk": "0355e6694d184384bc0c002ba49a2d00"}, {"fields": {"category": "Border Removal", "description": "\"**border_removal** (int *win_dil* = 3, int *win_avg* = 5, int *win_med* = 5, float *threshold1_scale* = 0.80, float *threshold1_gradient* = 6.00, float *threshold2_scale* = 0.80, float *threshold2_gradient* = 6.00, float *transfer_parameter* = 0.25, int *terminate_time1* = 15, int *terminate_time2* = 23, int *terminate_time3* = 75, int *interval2* = 45, int *interval3* = 15)\n\nReturns the mask of music score region.\n\nGathers paper_estimation, edge_detection and boundary_reconstruct functions.\"", "settings": "[{\"default\": 3, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"win_dil\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"win_avg\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"win_med\", \"type\": \"int\"}, {\"default\": \"0.8\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold1_scale\", \"type\": \"real\"}, {\"default\": \"6.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold1_gradient\", \"type\": \"real\"}, {\"default\": \"0.8\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold2_scale\", \"type\": \"real\"}, {\"default\": \"6.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold2_gradient\", \"type\": \"real\"}, {\"default\": \"0.25\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"transfer_parameter\", \"type\": \"real\"}, {\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"terminate_time1\", \"type\": \"int\"}, {\"default\": 23, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"terminate_time2\", \"type\": \"int\"}, {\"default\": 75, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"terminate_time3\", \"type\": \"int\"}, {\"default\": 45, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"interval2\", \"type\": \"int\"}, {\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"interval3\", \"type\": \"int\"}]", "author": "Yue Phyllis Ouyang and John Ashley Burgoyne", "enabled": true, "job_name": "gamera.toolkits.border_removal.plugins.border_removal.border_removal", "interactive": false}, "model": "rodan.job", "pk": "0995d1c57c8f445b8b485912c771139b"}, {"fields": {"category": "Background Estimation", "description": "\"**binarization** (``Image`` [OneBit] *mask*, ``FloatVector`` *reference_histogram*, int *do_wiener* = 0, int *wiener_width* = 5, int *wiener_height* = 3, float *noise_variance* = -1.00, int *med_size* = 17, int *region size* = 15, float *sensitivity* = 0.50, int(1, 255) *dynamic range* = 128, int(0, 255) *lower bound* = 20, int(0, 255) *upper bound* = 150, float *q* = 0.06, float *p1* = 0.70, float *p2* = 0.50)\n\n\n\n    *mask*\n      Mask image that defines the process region\n\n    *do_wiener*\n      1 if adding wiener filtering before binarization, otherwise 0\n\n    *region_width*, *region_height*, *noise_variance*\n      parameters for wiener filter\n\n    *med_size*\n      The kernel for median filter.\n\n    *region size*, *sensitivity*, *dynamic range*, *lower bound*, *upper bound*\n      parameters for sauvola binarization\n\n    *q*, *p1*, *p2*\n      parameters for gatos thresholding\n\n    the default values for wiener and median filtrs works best for image with size 1000*1000 to 2000*2000\n    Use the default settings for the other parameters unless you know\n    what you are doing.\n    \"", "settings": "[{\"has_default\": false, \"name\": \"mask\", \"default\": null, \"list_of\": false, \"pixel_types\": [0], \"type\": \"imagetype\"}, {\"has_default\": false, \"name\": \"reference_histogram\", \"default\": [], \"list_of\": false, \"length\": -1, \"type\": \"floatvector\"}, {\"default\": 0, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"do_wiener\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"wiener_width\", \"type\": \"int\"}, {\"default\": 3, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"wiener_height\", \"type\": \"int\"}, {\"default\": \"-1.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"noise_variance\", \"type\": \"real\"}, {\"default\": 17, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"med_size\", \"type\": \"int\"}, {\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region size\", \"type\": \"int\"}, {\"default\": \"0.5\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"sensitivity\", \"type\": \"real\"}, {\"default\": 128, \"has_default\": true, \"rng\": [1, 255], \"name\": \"dynamic range\", \"type\": \"int\"}, {\"default\": 20, \"has_default\": true, \"rng\": [0, 255], \"name\": \"lower bound\", \"type\": \"int\"}, {\"default\": 150, \"has_default\": true, \"rng\": [0, 255], \"name\": \"upper bound\", \"type\": \"int\"}, {\"default\": \"0.06\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"q\", \"type\": \"real\"}, {\"default\": \"0.7\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"p1\", \"type\": \"real\"}, {\"default\": \"0.5\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"p2\", \"type\": \"real\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.background_estimation.plugins.background_estimation.binarization", "interactive": false}, "model": "rodan.job", "pk": "0a598f95f54e4ead96d7ed9b4c5a987c"}, {"fields": {"category": "Binarization", "description": "\"**white_rohrer_threshold** (int *x lookahead* = 8, int *y lookahead* = 1, int *bias mode* = 0, int *bias factor* = 100, int *f factor* = 100, int *g factor* = 100)\n\nCreates a binary image using White and Rohrer's dynamic thresholding\nalgorithm. It is the first of the two algorithms described in:\n\nJ. M. White and G. D. Rohrer. 1983. Image thresholding for optical\ncharacter recognition and other applications requiring character\nimage extraction.  *IBM J. Res. Dev.* 27(4), pp. 400-411\n\nThe algorithm uses a 'running' average instead of true average of\nthe gray values in the neighborhood.  The lookahead parameter\ngives the number of lookahead pixels used in the biased running\naverage that is used in deciding the threshold at each pixel\nlocation.\n\n*x_lookahead*\n  the number of lookahead pixels in the horizontal direction for\n  computing the running average. White and Rohrer suggest a value\n  of 8 for a 240 dpi scanning resolution.\n\n*y_lookahead*\n  number of lines used for further averaging from the horizontal\n  averages.\n\nThe other parameters are for calculating biased running average.\nWithout bias the thresholding decision would be determined by\nnoise fluctuations in uniform areas.\n\nThis implementation uses code from XITE__.\n\n.. __: http://www.ifi.uio.no/forskning/grupper/dsb/Software/Xite/\n\n.. note::\n\n   Permission to use, copy, modify and distribute this software\n   and its documentation for any purpose and without fee is hereby\n   granted, provided that this copyright notice appear in all\n   copies and that both that copyright notice and this permission\n   notice appear in supporting documentation and that the name of\n   B-lab, Department of Informatics or University of Oslo not be\n   used in advertising or publicity pertaining to distribution of\n   the software without specific, written prior permission.\n\n   B-LAB DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n   INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n   FITNESS, IN NO EVENT SHALL B-LAB BE LIABLE FOR ANY SPECIAL,\n   INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER\n   RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n   ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n   THIS SOFTWARE.\"", "settings": "[{\"default\": 8, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"x lookahead\", \"type\": \"int\"}, {\"default\": 1, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"y lookahead\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"bias mode\", \"type\": \"int\"}, {\"default\": 100, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"bias factor\", \"type\": \"int\"}, {\"default\": 100, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"f factor\", \"type\": \"int\"}, {\"default\": 100, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"g factor\", \"type\": \"int\"}]", "author": "Uma Kompella (using code from the XITE library)", "enabled": true, "job_name": "gamera.plugins.binarization.white_rohrer_threshold", "interactive": false}, "model": "rodan.job", "pk": "0a9b1aaada4348feb337689c06880fa5"}, {"fields": {"category": "MusicStaves", "description": "\"**correct_rotation** (int *staffline_height* = 0)\n\nCorrects a possible rotation angle with the aid of skewed projections.\n\nWhen the image is large, it is temporarily scaled down for performance\nreasons. The parameter *staffline_height* determines how much the image\nis scaled down: when it is larger than 3, the image is scaled down so that\nthe resulting staffline height is 2. Thus if you want to suppress the\ndownscaling, set *staffline_height* to one.\n\nWhen *staffline_height* is given as zero, it is computed automatically\nas most frequent black vertical run.\n    \"", "settings": "[{\"default\": 0, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"staffline_height\", \"type\": \"int\"}]", "author": "Christoph Dalitz", "enabled": true, "job_name": "gamera.toolkits.musicstaves.plugins.musicstaves_plugins.correct_rotation", "interactive": false}, "model": "rodan.job", "pk": "0bbd37548ce94bc399fed763f7fadb7c"}, {"fields": {"category": "Border and Lyric Extraction", "description": "\"**correct_rotation** (int *staffline_height* = 0)\n\nCorrects a possible rotation angle with the aid of skewed projections.\n\nWhen the image is large, it is temporarily scaled down for performance\nreasons. The parameter *staffline_height* determines how much the image\nis scaled down: when it is larger than 3, the image is scaled down so that\nthe resulting staffline height is 2. Thus if you want to suppress the\ndownscaling, set *staffline_height* to one.\n\nWhen *staffline_height* is given as zero, it is computed automatically\nas most frequent black vertical run.\n\nThis function is adapted from Gamera MusicStaves Toolkit.\n    \"", "settings": "[{\"default\": 0, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"staffline_height\", \"type\": \"int\"}]", "author": "Christoph Dalitz", "enabled": true, "job_name": "gamera.toolkits.lyric_extraction.plugins.border_lyric.correct_rotation", "interactive": false}, "model": "rodan.job", "pk": "0d1a0908eaee426e99b0b3742eb84537"}, {"fields": {"category": "Staff Removal", "description": "\"**staff_removal** (int *staffspace* = -1, int *staffheight* = -1, float *scalar_med_width_staffspace* = 0.15, float *scalar_med_height_staffspace* = 0.60, float *scalar_med_width_staffheight* = 1.20, float *scalar_med_height_staffheight* = 5.00, int *neighbour_width* = 1, int *neighbour_height* = 1, int *staff_win* = 30, int *staffspace_threshold1* = 5, int *staffspace_threshold2* = 10)\n\nRemoves stafflines from music scores.\nNote: it is specially for lyric line detection and cannot be used directly for standard staff removal.\n\nMain process: directional median filter -> reconsider pixels in neighbourhood of potential non-staff pixels\n\n*staffspace*\n    staffspace height. If negative, estimated automatically.\n\n*staffheight*\n    staff height. If negative, estimated automatically.\n\n*scalar_med_width_staffspace*, *scalar_med_height_staffspace*\n    (scalar_med_width_staffspace*staffspace, scalar_med_height_staffspace*staffspace):\n    region size for median filter estimated from staffspace.\n\n*scalar_med_width_staffheight*, *scalar_med_height_staffheight*\n    (scalar_med_width_staffheight*staffheight, scalar_med_height_staffheight*staffheight):\n    region size for median filter estimated from staffheight.\n\n*neighbour_width*, *neighbour_height*\n    region size defined as neighbourhood of a pixel.\n\n*staff_win*\n    width of each vertical strip. Local projection is done within each strip.\n\n*staffspace_threshold1*, *staffspace_threshold2*\n    staffspace_threshold1 is the minimum height of staffline height. If the estimation is underneath this threshold,\n    chose the next peak whose staffspace is over staffspace_threshold2\"", "settings": "[{\"default\": -1, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"staffspace\", \"type\": \"int\"}, {\"default\": -1, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"staffheight\", \"type\": \"int\"}, {\"default\": \"0.15\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_med_width_staffspace\", \"type\": \"real\"}, {\"default\": \"0.6\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_med_height_staffspace\", \"type\": \"real\"}, {\"default\": \"1.2\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_med_width_staffheight\", \"type\": \"real\"}, {\"default\": \"5.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_med_height_staffheight\", \"type\": \"real\"}, {\"default\": 1, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"neighbour_width\", \"type\": \"int\"}, {\"default\": 1, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"neighbour_height\", \"type\": \"int\"}, {\"default\": 30, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"staff_win\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"staffspace_threshold1\", \"type\": \"int\"}, {\"default\": 10, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"staffspace_threshold2\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.staffline_removal.plugins.staff_removal.staff_removal", "interactive": false}, "model": "rodan.job", "pk": "2058a8042b6c41f9a144544e41a625f1"}, {"fields": {"category": "Cropping", "description": "\"**rdn_crop** (int *ulx*, int *uly*, int *lrx*, int *lry*, int *imw*)\n\nA thin wrapper around subimage() to get the\ndesired cropping behaviour for Rodan.\n\nSee http://gamera.sourceforge.net/doc/html/utility.html#subimage\nfor more info on why this is necessary.\"", "settings": "[{\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"ulx\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"uly\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"lrx\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"lry\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"imw\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.rodan_plugins.plugins.rdn_crop.rdn_crop", "interactive": true}, "model": "rodan.job", "pk": "2060ebbdc7fe402a87738d381b19dab9"}, {"fields": {"category": "Border Removal", "description": "Automatically tries to remove the border of a page. Non-interactive.", "settings": "[{\"default\": 3, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"win_dil\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"win_avg\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"win_med\", \"type\": \"int\"}, {\"default\": \"0.8\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold1_scale\", \"type\": \"real\"}, {\"default\": \"6.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold1_gradient\", \"type\": \"real\"}, {\"default\": \"0.8\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold2_scale\", \"type\": \"real\"}, {\"default\": \"6.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold2_gradient\", \"type\": \"real\"}, {\"default\": \"0.25\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"transfer_parameter\", \"type\": \"real\"}, {\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"terminate_time1\", \"type\": \"int\"}, {\"default\": 23, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"terminate_time2\", \"type\": \"int\"}, {\"default\": 75, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"terminate_time3\", \"type\": \"int\"}, {\"default\": 45, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"interval2\", \"type\": \"int\"}, {\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"interval3\", \"type\": \"int\"}]", "author": "Deepanjan Roy", "enabled": true, "job_name": "gamera.custom.border_removal.auto_border_removal", "interactive": false}, "model": "rodan.job", "pk": "2753be2486434a8bbed715c325c1c037"}, {"fields": {"category": "Transformation", "description": "\"**rotate** (float(-180.00, 180.00) *angle*, Pixel *bgcolor* = None, int(1, 3) *order* = 1)\n\nRotates an image.\n\n*angle*\n  The angle of rotation (in degrees)\n\n*bgcolor*\n  The color to use for pixels outside of the original image bounds.\n  When *bgcolor* is ``None``, white is used.\n\n*order*\n  The order of the spline used for interpolation.  Must be between 1 - 3.\"", "settings": "[{\"default\": \"0.0\", \"has_default\": false, \"rng\": [-180, 180], \"name\": \"angle\", \"type\": \"real\"}, {\"default\": null, \"has_default\": true, \"type\": \"pixel\", \"name\": \"bgcolor\", \"list_of\": false}, {\"default\": 1, \"has_default\": true, \"rng\": [1, 3], \"name\": \"order\", \"type\": \"int\"}]", "author": "Michael Droettboom (With code from VIGRA by Ullrich K\u00f6the)", "enabled": true, "job_name": "gamera.plugins.transformation.rotate", "interactive": false}, "model": "rodan.job", "pk": "29f07ded6449431c85720be5e42768e2"}, {"fields": {"category": "Border and Lyric Extraction", "description": "\"**border_removal_and_binarization** ()\n\nRemoves color bar and other border stuff, binarizes image.\n       For best performance, scale the image around 1000*1000 to 2000*2000\n    \"", "settings": "[]", "author": null, "enabled": true, "job_name": "gamera.toolkits.lyric_extraction.plugins.border_lyric.border_removal_and_binarization", "interactive": false}, "model": "rodan.job", "pk": "342f40664d334d6994db7e2ab23db166"}, {"fields": {"category": "Binarization", "description": "\"**sauvola_threshold** (int *region size* = 15, float *sensitivity* = 0.50, int(1, 255) *dynamic range* = 128, int(0, 255) *lower bound* = 20, int(0, 255) *upper bound* = 150)\n\nCreates a binary image using Sauvola's adaptive algorithm.\n\nSauvola, J. and M. Pietikainen. 2000. Adaptive document image\nbinarization.  *Pattern Recognition* 33: 225--236.\n\nLike the QGAR library, there are two extra global thresholds for\nthe lightest and darkest regions.\n\n*region_size*\n  The size of the region in which to calculate a threshold.\n\n*sensitivity*\n  The sensitivity weight on the adjusted variance.\n\n*dynamic_range*\n  The dynamic range of the variance.\n\n*lower bound*\n  A global threshold beneath which all pixels are considered black.\n\n*upper bound*\n  A global threshold above which all pixels are considered white.\"", "settings": "[{\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region size\", \"type\": \"int\"}, {\"default\": \"0.5\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"sensitivity\", \"type\": \"real\"}, {\"default\": 128, \"has_default\": true, \"rng\": [1, 255], \"name\": \"dynamic range\", \"type\": \"int\"}, {\"default\": 20, \"has_default\": true, \"rng\": [0, 255], \"name\": \"lower bound\", \"type\": \"int\"}, {\"default\": 150, \"has_default\": true, \"rng\": [0, 255], \"name\": \"upper bound\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.plugins.binarization.sauvola_threshold", "interactive": false}, "model": "rodan.job", "pk": "396a962929624192b7a424d7585a3b85"}, {"fields": {"category": "Dummy", "description": "A Dummy Job for testing the Job loading and workflow system", "settings": "[{\"default\": null, \"has_default\": false, \"type\": \"imagetype\", \"name\": \"mask\", \"pixel_types\": 0}, {\"has_default\": false, \"name\": \"reference_histogram\", \"default\": [], \"list_of\": false, \"length\": -1, \"type\": \"floatvector\"}]", "author": "Andrew Hankinson", "enabled": true, "job_name": "rodan.jobs.devel.dummy_job", "interactive": false}, "model": "rodan.job", "pk": "39fedad08e8d4467bd47db8cd96ee7d2"}, {"fields": {"category": "Transformation", "description": "\"**resize** (``Dim`` *dim*, ``Choice`` [None|Linear|Spline] *interp_type*)\n\nReturns a resized copy of an image. In addition to size, the type\nof interpolation can be specified, with a tradeoff between speed\nand quality.\n\nIf you need to maintain the aspect ratio of the original image,\nconsider using scale_ instead.\n\n*dim*\n  The size of the resulting image.\n\n*interp_type* [None|Linear|Spline]\n  The type of interpolation used to resize the image.  Each option\n  is progressively higher quality, yet slower.\n\n.. _scale: #scale\"", "settings": "[{\"default\": [0, 0], \"has_default\": false, \"type\": \"dim\", \"name\": \"dim\"}, {\"default\": 0, \"has_default\": false, \"type\": \"choice\", \"name\": \"interp_type\", \"choices\": [\"None\", \"Linear\", \"Spline\"]}]", "author": null, "enabled": true, "job_name": "gamera.plugins.transformation.resize", "interactive": false}, "model": "rodan.job", "pk": "3aef283522604c3081b18f44613b2682"}, {"fields": {"category": "Staff Removal", "description": "\"**directional_med_filter_bw** (int *region_width* = 5, int *region_height* = 5)\n\nReturns the regional intermediate value of an image as a FLOAT.\nThe shape of window is not necessarily a square.\nThis function currently only works on binary image.\n\n*region_width*, *region_height*\n  The size of the region within which to calculate the intermediate pixel value.\"", "settings": "[{\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region_width\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region_height\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.staffline_removal.plugins.staff_removal.directional_med_filter_bw", "interactive": false}, "model": "rodan.job", "pk": "41778fa15bd547468ac5443c974b3330"}, {"fields": {"category": "Border Removal", "description": "\"**flood_fill_holes_grey** ()\n\nFills holes in an image by flood fill.\n\nAlgorithm reference: Luc Vincent, \"Morphological Grayscale Reconstruction\nIn Image Analysis: Applications and Efficient Algorithms\", IEEE Transactions\non Image Processing, vol.2, no.2, April 1993, pp. 176-201\n\nNote: this function only works on greyscale image.\"", "settings": "[]", "author": "Yue Phyllis Ouyang and John Ashley Burgoyne", "enabled": true, "job_name": "gamera.toolkits.border_removal.plugins.border_removal.flood_fill_holes_grey", "interactive": false}, "model": "rodan.job", "pk": "4deaa5c9d3a04827aa31a84ec947ee5a"}, {"fields": {"category": "Despeckling", "description": "\"**rdn_despeckle** (int(1, 100) *cc_size*, int *image_width*)\n\nA thin wrapper around despeckle() to get the\ndesired despeckling behaviour for Rodan.\n\nDesired behaviour involves returning a gamera Image, rather\njust applying it to the image that is passed in and returning nothingm,\nand also scaling the cc_size, although I'm (Deepanjan) not sure if this works.\"", "settings": "[{\"default\": 0, \"has_default\": false, \"rng\": [1, 100], \"name\": \"cc_size\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"image_width\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.rodan_plugins.plugins.rdn_despeckle.rdn_despeckle", "interactive": true}, "model": "rodan.job", "pk": "511697605f21471a891c4680db4cd1ec"}, {"fields": {"category": "MusicStaves", "description": "\"**match_staff_template** (int *width*, int *line_distance*, int *nlines* = 2, int(1, 100) *blackness* = 70)\n\nExtracts all points from an image that match a staff template.\n\nThe template consists of *nlines* horizontal lines of width *width* with\na vertical distance *line_distance*. The midpoint of each line is extracted\nif each line contains more than *blackness* percent black pixels. In order\nto avoid cutting off the staff lines at the beginning and end of each staff,\nthe lines are extrapolated at the ends until no further black point is found.\n\nReasonable parameter values are *3 * staffspace_height / 2* for *width* and\n*staffspace_height + staffline_height* for *line_distance*.\n\"", "settings": "[{\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"width\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"line_distance\", \"type\": \"int\"}, {\"default\": 2, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"nlines\", \"type\": \"int\"}, {\"default\": 70, \"has_default\": true, \"rng\": [1, 100], \"name\": \"blackness\", \"type\": \"int\"}]", "author": "Christoph Dalitz", "enabled": true, "job_name": "gamera.toolkits.musicstaves.plugins.musicstaves_plugins.match_staff_template", "interactive": false}, "model": "rodan.job", "pk": "5198d02d28854289a1188e3b8e588b27"}, {"fields": {"category": "Background Estimation", "description": "\"**equalise_histogram_mask** (``Image`` [OneBit] *mask*, ``FloatVector`` *reference_histogram*)\n\nNormalises the histogram of the given image to match an input\nhistogram within mask region\"", "settings": "[{\"has_default\": false, \"name\": \"mask\", \"default\": null, \"list_of\": false, \"pixel_types\": [0], \"type\": \"imagetype\"}, {\"has_default\": false, \"name\": \"reference_histogram\", \"default\": [], \"list_of\": false, \"length\": -1, \"type\": \"floatvector\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.background_estimation.plugins.background_estimation.equalise_histogram_mask", "interactive": false}, "model": "rodan.job", "pk": "563d01c6710b491abc27984d521735ff"}, {"fields": {"category": "Binarization", "description": "\"**gatos_background** (``Image`` [OneBit] *binarization*, int *region size* = 15)\n\nEstimates the background of an image according to Gatos et al.'s\nmethod. See:\n\nGatos, Basilios, Ioannis Pratikakis, and Stavros\nJ. Perantonis. 2004. An adaptive binarization technique for low\nquality historical documents. *Lecture Notes in Computer\nScience* 3163: 102--113.\n\n*region_size* \n  Region size for interpolation.\n\n*binarization*\n  A preliminary binarization of the image.\"", "settings": "[{\"has_default\": false, \"name\": \"binarization\", \"default\": null, \"list_of\": false, \"pixel_types\": [0], \"type\": \"imagetype\"}, {\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region size\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.plugins.binarization.gatos_background", "interactive": false}, "model": "rodan.job", "pk": "56da8d6782654ec99a357c75ce48d4b4"}, {"fields": {"category": "Conversion", "description": "\"**to_rgb** ()\n\nConverts the given image to an RGB image according to teh following rules:\n\n- for ONEBIT images, 0 is mapped to (255,255,255) and everything else to (0,0,0)\n- for GREYSCALE and GREY16 images, R=G=B\n- for FLOAT images, the range [min,max] is linearly mapped to the 256 grey values\n\nNote, converting an image to one of the same type performs a copy operation.\"", "settings": "[]", "author": "Michael Droettboom, Karl MacMillan, and Christoph Dalitz", "enabled": true, "job_name": "gamera.plugins.image_conversion.to_rgb", "interactive": false}, "model": "rodan.job", "pk": "5e8fdb687f2b43bb93403a37d9282980"}, {"fields": {"category": "Border Removal", "description": "\"**flood_fill_bw** ()\n\nFlood fill on binary image.\n\nIt is different from filling holes in the way generating marker and mask images.\n\nAlgorithm reference: Luc Vincent, \"Morphological Grayscale Reconstruction\nIn Image Analysis: Applications and Efficient Algorithms\", IEEE Transactions\non Image Processing, vol.2, no.2, April 1993, pp. 176-201\"", "settings": "[]", "author": "Yue Phyllis Ouyang and John Ashley Burgoyne", "enabled": true, "job_name": "gamera.toolkits.border_removal.plugins.border_removal.flood_fill_bw", "interactive": false}, "model": "rodan.job", "pk": "623f972ab24d4f2d979cb255fb127efc"}, {"fields": {"category": "Binarization", "description": "\"**otsu_threshold** (``Choice`` [dense|rle] *storage format*)\n\nCreates a binary image by splitting along a threshold value\ndetermined using the Otsu algorithm.\n\nEquivalent to ``image.threshold(image.otsu_find_threshold())``.\n\n*storage_format* (optional)\n  specifies the compression type for the result:\n  \n  DENSE (0)\n    no compression\n  RLE (1)\n    run-length encoding compression\"", "settings": "[{\"default\": 0, \"has_default\": false, \"type\": \"choice\", \"name\": \"storage format\", \"choices\": [\"dense\", \"rle\"]}]", "author": null, "enabled": true, "job_name": "gamera.plugins.threshold.otsu_threshold", "interactive": false}, "model": "rodan.job", "pk": "664e0e24242a428e912ca12bc6008a97"}, {"fields": {"category": "Conversion", "description": "\"**extract_imaginary** ()\n\nReturns a Float image containing only the imaginary values in the\ngiven complex image.\"", "settings": "[]", "author": null, "enabled": true, "job_name": "gamera.plugins.image_conversion.extract_imaginary", "interactive": false}, "model": "rodan.job", "pk": "665747e471f8408e9ff47db93fb0190a"}, {"fields": {"category": "Conversion", "description": "\"**to_greyscale** ()\n\nConverts the given image to a GREYSCALE image according to the\nfollowing rules:\n\n- for ONEBIT images, 0 is mapped to 255 and everything else to 0.\n- for FLOAT images, the range [min,max] is linearly scaled to [0,255]\n- for GREY16 images, the range [0,max] is linearly scaled to [0,255]\n- for RGB images, the luminance is used, which is defined in VIGRA as 0.3*R + 0.59*G + 0.11*B\n\nConverting an image to one of the same type performs a copy operation.\"", "settings": "[]", "author": "Michael Droettboom, Karl MacMillan, and Christoph Dalitz", "enabled": true, "job_name": "gamera.plugins.image_conversion.to_greyscale", "interactive": false}, "model": "rodan.job", "pk": "67b8845fb5b74f809b30c77656c9897c"}, {"fields": {"category": "Background Estimation", "description": "\"**background_estimation** (int *med_size* = 17)\n\nbackground estimation\n\n*med_size*\n    the kernel for median filter.\n    the default value works best for image with size 1000*1000 to 2000*2000\"", "settings": "[{\"default\": 17, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"med_size\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.background_estimation.plugins.background_estimation.background_estimation", "interactive": false}, "model": "rodan.job", "pk": "6accf1e75bbf4556ad498ae43309fe00"}, {"fields": {"category": "Binarization", "description": "\"**djvu_threshold** (float(0.00, 1.00) *smoothness* = 0.20, int *max_block_size* = 512, int *min_block_size* = 64, int(1, 8) *block_factor* = 2)\n\nCreates a binary image by using the DjVu thresholding algorithm.\n\nSee Section 5.1 in:\n\n  Bottou, L., P. Haffner, P. G. Howard, P. Simard, Y. Bengio and\n  Y. LeCun.  1998.  High Quality Document Image Compression with\n  DjVu.  AT&T Labs, Lincroft, NJ.\n\n  http://research.microsoft.com/~patrice/PDF/jei.pdf\n\nThis implementation features an additional extension to the\nalgorithm described above.  Once the background and foreground\ncolors are determined for each block, the image is thresholded by\ninterpolating the foreground and background colors between the\nblocks.  This prevents \"blockiness\" along boundaries of strong\ncolor change.\n\n*smoothness*\n  The amount of effect that parent blocks have on their children\n  blocks.  Higher values will result in more smoothness between\n  blocks.  Expressed as a percentage between 0.0 and 1.0.\n\n*max_block_size*\n  The size of the largest block to determine a threshold.\n\n*min_block_size*\n  The size of the smallest block to determine a threshold.\n\n*block_factor*\n  The number of child blocks (in each direction) per parent block.\n  For instance, a *block_factor* of 2 results in 4 children per\n  parent.\"", "settings": "[{\"default\": \"0.2\", \"has_default\": true, \"rng\": [\"0.0\", \"1.0\"], \"name\": \"smoothness\", \"type\": \"real\"}, {\"default\": 512, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"max_block_size\", \"type\": \"int\"}, {\"default\": 64, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"min_block_size\", \"type\": \"int\"}, {\"default\": 2, \"has_default\": true, \"rng\": [1, 8], \"name\": \"block_factor\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.plugins.threshold.djvu_threshold", "interactive": false}, "model": "rodan.job", "pk": "793ddd9d4e0349e9a6746fa415d3e97f"}, {"fields": {"category": "Transformation", "description": "\"**grey_convert** (``IntVector`` *newgrey*)\n\nConverts grey values to the new values provided in the vector *newgrey*,\ni.e. *val* is replaced by *newgrey[val]*.\n\nAs this is only implemented for greyscale images, the vector *newgrey*\nmust be of size 256 and all entries must be in [0,255].\"", "settings": "[{\"has_default\": false, \"name\": \"newgrey\", \"default\": [], \"list_of\": false, \"length\": -1, \"type\": \"intvector\"}]", "author": "Fabian Schmitt and Christoph Dalitz", "enabled": true, "job_name": "gamera.plugins.transformation.grey_convert", "interactive": false}, "model": "rodan.job", "pk": "7a19f126eed44075a32f2c85db1ef1ff"}, {"fields": {"category": "Border Removal", "description": "Manual masking crop. Uses the crop interface. Interactive.", "settings": "[{\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"ulx\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"uly\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"lrx\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"lry\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"imw\", \"type\": \"int\"}]", "author": "Deepanjan Roy", "enabled": true, "job_name": "gamera.custom.border_removal.crop_border_removal", "interactive": true}, "model": "rodan.job", "pk": "7a31b84b50ca42d38e019a0dc4ece655"}, {"fields": {"category": "Lyric Line Extraction", "description": "\"**lyric_line_fit** (``Image`` [OneBit] *baseline*, float *lyric_height*, float *fit_angle_degree* = 2.50, float *scalar_search_height* = 1.20, float *scalar_fit_up* = 1.20, float *scalar_fit_down* = 0.30)\n\nReturns the mask of lyric lines.\nThe lines are estimated by linear least square fitting from local minimum vertex map of lyric baseline.\n\n*baseline*\n    local minimum vertex map of lyric baseline.\n\n*lyric_height*\n    estimation of average lyric height.\n\n*fit_angle_degree*\n    tolerance on angle between lyric line and horizon(in degree).\n\n*scalar_search_height*\n    scala_search_height*lyric_height: tolerance on distance (in y-axis) between local minimum vertices that belong to a single lyric line.\n\n*scalar_fit_up*\n    scalar_fit_up*lyric_height: height of lyric portion above baseline.\n\n*scalar_fit_down*\n    scalar_fit_down*lyric_height: height of lyric portion beneath baseline.\n\nNote: no post-processing to extract precise posistion of each lyric or deal with overlapping situation is applied.\"", "settings": "[{\"has_default\": false, \"name\": \"baseline\", \"default\": null, \"list_of\": false, \"pixel_types\": [0], \"type\": \"imagetype\"}, {\"default\": \"0.0\", \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"lyric_height\", \"type\": \"real\"}, {\"default\": \"2.5\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"fit_angle_degree\", \"type\": \"real\"}, {\"default\": \"1.2\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_search_height\", \"type\": \"real\"}, {\"default\": \"1.2\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_fit_up\", \"type\": \"real\"}, {\"default\": \"0.3\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_fit_down\", \"type\": \"real\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.lyric_extraction.plugins.lyricline.lyric_line_fit", "interactive": false}, "model": "rodan.job", "pk": "87e4116c7d854c0eb6a0ba5a69a5bdad"}, {"fields": {"category": "Conversion", "description": "\"**extract_real** ()\n\nReturns a Float image containing only the real values in the given\ncomplex image.\"", "settings": "[]", "author": null, "enabled": true, "job_name": "gamera.plugins.image_conversion.extract_real", "interactive": false}, "model": "rodan.job", "pk": "8dab87ef3cc1434b8cba4302ab3fc3eb"}, {"fields": {"category": "Border and Lyric Extraction", "description": "\"**extract_lyrics** (int *minimum_y_threshold* = 10, int *num_searches* = 4, int *negative_bound* = 10, int *postive_bound* = 10)\n\nTakes in a binarised image and attempts to remove lyrics by processing horizontal\nprojections (see find_blackest_lines).  Whatever lines are found from find_blackest_lines\nare superimposed onto the connected components of the image.  Those CCs are then removed\nfrom the binarised image.\n\nParameters:\n\n  minimum_y_threshold: the minimum value that may be considered a local peak\n  in the horizontal projection.\n\n  num_searches: the number of searches to do around each local peak\n\n  negative_bound: how far below the local peak to start the line search (this\n  value is positive! so the value of negative_bound=10 will start searching 10\n  pixels below the peak-point (or -10 pixels. To make this even more\n  confusing, the negative direction is actually upward when talking about\n  images, but you already knew this from reading the Gamera documentation).\n\n  positive_bound: how far above the local peak to start the line search\n\n  delta: see the delta parameter for the peakdet function above\"", "settings": "[{\"default\": 10, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"minimum_y_threshold\", \"type\": \"int\"}, {\"default\": 4, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"num_searches\", \"type\": \"int\"}, {\"default\": 10, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"negative_bound\", \"type\": \"int\"}, {\"default\": 10, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"postive_bound\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.lyric_extraction.plugins.lyric_extractor.extract_lyrics", "interactive": false}, "model": "rodan.job", "pk": "9076ff8c6f2c4ef6b3234519fa9ee6e3"}, {"fields": {"category": "Lyric Line Extraction", "description": "\"**baseline_detection** (float *staffspace*, int *threshold_noise* = 15, float *scalar_cc_strip* = 1.00, float *seg_angle_degree* = 30.00, float *scalar_seg_dist* = 3.50, int *min_group* = 4, float *merge_angle_degree* = 5.00, float *scalar_merge_dist* = 5.00, float *valid_angle_degree* = 20.00, float *scalar_valid_height* = 1.00, int *valid_min_group* = 8)\n\nDetects the baseline of lyrics.\nReturns the local minimum vertex map of lyric baseline.\n\n*staffspace*\n    staffspace height.\n\n*thershold noise*\n    minimum area of connected component not considered as noise.\n\n*scalar_cc_strip*\n    long connected components are broked into strips with certain width, scalar_cc_strip*staffspace.\n\n*seg_angle_degree*\n    tolerance on angle between two adjacent local minimum vertices of the same line (in degree).\n\n*scalar_seg_dist*\n    scalar_seg_dist*staffspace: tolerance on distance (in x-axis) between two adjacent local minimum vertices of the same line.\n\n*min_group*\n    minimun number of local minimum vertices in a potential baseline segment.\n\n*merge_angle_degree*\n    tolerance on angle between two adjacent potential baseline segments to merge into one line (in degree).\n\n*scalar_merge_dist*\n    scalar_merge_dist*staffspace: tolerance on distance (in x-axis) between two adjacent potential baseline segments to merge into one line.\n\n*valid_angle_degree*\n    tolerance on angle between baseline and horizon(in degree).\n\n*scalar_valid_height*\n    scala_valid_height*staffspace: tolerance on distance (in y-axis) between local minimum vertices and the estimated baseline they belong to.\n\n*valid_min_group*\n    minimun number of local minimum vertices in a baseline.\"", "settings": "[{\"default\": \"0.0\", \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"staffspace\", \"type\": \"real\"}, {\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold_noise\", \"type\": \"int\"}, {\"default\": \"1.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_cc_strip\", \"type\": \"real\"}, {\"default\": \"30.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"seg_angle_degree\", \"type\": \"real\"}, {\"default\": \"3.5\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_seg_dist\", \"type\": \"real\"}, {\"default\": 4, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"min_group\", \"type\": \"int\"}, {\"default\": \"5.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"merge_angle_degree\", \"type\": \"real\"}, {\"default\": \"5.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_merge_dist\", \"type\": \"real\"}, {\"default\": \"20.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"valid_angle_degree\", \"type\": \"real\"}, {\"default\": \"1.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_valid_height\", \"type\": \"real\"}, {\"default\": 8, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"valid_min_group\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.lyric_extraction.plugins.lyricline.baseline_detection", "interactive": false}, "model": "rodan.job", "pk": "92227cc83ece4b1fa6649bd4729fcff1"}, {"fields": {"category": "Lyric Extraction", "description": "TO DO", "settings": "[{\"has_default\": true, \"name\": \"image_width\", \"default\": 0, \"rng\": [-1048576, 1048576], \"visibility\": false, \"type\": \"int\"}, {\"default\": null, \"has_default\": true, \"type\": \"json\", \"name\": \"geometries\", \"visibility\": false}]", "author": "Ryan Bannon", "enabled": true, "job_name": "gamera.custom.lyric_extraction.pixel_segment", "interactive": true}, "model": "rodan.job", "pk": "95a949fc60d24c6291930976b30e02a6"}, {"fields": {"category": "Rotation", "description": "\"**rdn_rotate** (float *angle*)\n\nA thin wrapper around rotate() to get the\ndesired rotate behaviour for Rodan.\n\nThe rotate function in gamera will be executed even\nif an angle value of 0 is passed in, which we want\nto avoid.\"", "settings": "[{\"default\": \"0.0\", \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"angle\", \"type\": \"real\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.rodan_plugins.plugins.rdn_rotate.rdn_rotate", "interactive": true}, "model": "rodan.job", "pk": "986a812fe433409fb6a7bc914e0df102"}, {"fields": {"category": "Binarization", "description": "\"**shading_subtraction** (int *k* = 7, int *threshold* = None)\n\nThresholds an image after subtracting a -possibly shaded- background.\n\nFirst the backgrund image is extracted with a maximum filter with a\n*k\\*k* window, and this image is subtracted from the original image.\nOn the difference image, a threshold is applied, and the inverted\nimage thereof is the binarization result.\n\nParameters:\n\n*k*\n  Window size of the maximum filter. Must be odd. For decent results,\n  it must be chosen so large that every window includes at least one\n  background pixel.\n\n*threshold*\n  Threshold applied to the difference image. A possibly reasonable\n  value might lie around 20. When ``None``, the threshold is\n  determined automatically with otsu_find_threshold_.\n\n.. _otsu_find_threshold: binarization.html#otsu-find-threshold\n\nReference: K.D. Toennies: *Grundlagen der Bildverarbeitung.* \nPearson Studium, 2005, p.202\"", "settings": "[{\"default\": 7, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"k\", \"type\": \"int\"}, {\"default\": null, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold\", \"type\": \"int\"}]", "author": "Christoph Dalitz", "enabled": true, "job_name": "gamera.plugins.binarization.shading_subtraction", "interactive": false}, "model": "rodan.job", "pk": "9c3e242bfa044b05aa0539ff25e447fc"}, {"fields": {"category": "Staff Removal", "description": "Removes the staff lines usign Roach and Tatem Staffline removal algorithm.", "settings": "[{\"default\": 0, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"staffline_height\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"staffspace_height\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"num_lines\", \"type\": \"int\"}, {\"default\": 3, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"resolution\", \"type\": \"real\"}]", "author": "Deepanjan Roy", "enabled": true, "job_name": "gamera.custom.staff_removal.RT_staff_removal", "interactive": false}, "model": "rodan.job", "pk": "9c63b822a0be4c06bab1a5415e8f56a4"}, {"fields": {"category": "Conversion", "description": "Converts an image to a JPEG2000 image suitable for display in Diva", "settings": "{}", "author": "Andrew Hankinson", "enabled": true, "job_name": "diva.conversion.to_jpeg2000", "interactive": false}, "model": "rodan.job", "pk": "a83dd02f8bd944598643c04bfe96eacc"}, {"fields": {"category": "Binarization", "description": "\"**soft_threshold** (int *t* = None, float *sigma* = 0.00, ``Choice`` [logistic|normal|uniform] *dist* = logistic)\n\nDoes a greyscale transformation that \"smears out\" the threshold *t* by a\nchoosable amount *sigma*. This has the effect of a \"soft\" thresholding.\n\nEach grey value *x* is transformed to *F(x,t,sigma)*, where *F*\nis the CDF probability distribution with mean *t* and variance\n*sigma^2*. The parameter *dist* determines the type of probability\ndistribution: 0 = logistic, 1 = normal (gaussian), 2 = uniform.\n\nAs the choice *sigma* = 0 is useless (it is the same as normal\nthresholding), this special value is reserved for an automatic selection\nof *sigma* with soft_threshold_find_sigma__.\n\n.. __: #soft-threshold-find-sigma\n\nWhen *t* is not given, it is automatically computed with\notsu_find_threshold__.\n\n.. __: #otsu-find-threshold\n\nReference: C. Dalitz: `\"Soft Thresholding for Visual Image Enhancement.\"`__\nTechnischer Bericht Nr. 2014-01, Hochschule Niederrhein,\nFachbereich Elektrotechnik und Informatik, 2014\n\n.. __: http://www.hsnr.de/fileadmin/dateien/fb03/gruppen/technische-berichte/fb03-tb-2014-01.pdf\"", "settings": "[{\"default\": null, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"t\", \"type\": \"int\"}, {\"default\": \"0.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"sigma\", \"type\": \"real\"}, {\"default\": 0, \"has_default\": true, \"type\": \"choice\", \"name\": \"dist\", \"choices\": [\"logistic\", \"normal\", \"uniform\"]}]", "author": "Christoph Dalitz", "enabled": true, "job_name": "gamera.plugins.threshold.soft_threshold", "interactive": false}, "model": "rodan.job", "pk": "a8dd3ed98eec42fb897c611699523d97"}, {"fields": {"category": "Background Estimation", "description": "\"**mask_fill** (``Image`` [OneBit] *mask*, int *color*)\n\nfills masked region with color\"", "settings": "[{\"has_default\": false, \"name\": \"mask\", \"default\": null, \"list_of\": false, \"pixel_types\": [0], \"type\": \"imagetype\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"color\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.background_estimation.plugins.background_estimation.mask_fill", "interactive": false}, "model": "rodan.job", "pk": "aca59d1423b44fdfb62b5d1a7decbca6"}, {"fields": {"category": "Conversion", "description": "\"**to_complex** ()\n\nConverts the given image to a COMPLEX image.\n\nNote, converting an image to one of the same type performs a copy operation.\"", "settings": "[]", "author": null, "enabled": true, "job_name": "gamera.plugins.image_conversion.to_complex", "interactive": false}, "model": "rodan.job", "pk": "b422fe02ca9e48e1a43c78ea0bcbdc66"}, {"fields": {"category": "Binarization", "description": "\"**niblack_threshold** (int *region size* = 15, float *sensitivity* = -0.20, int(0, 255) *lower bound* = 20, int(0, 255) *upper bound* = 150)\n\nCreates a binary image using Niblack's adaptive algorithm.\n\nNiblack, W. 1986. *An Introduction to Digital Image Processing.* Englewood\nCliffs, NJ: Prentice Hall.\n\nLike the QGAR library, there are two extra global thresholds for\nthe lightest and darkest regions.\n\n*region_size*\n  The size of the region in which to calculate a threshold.\n\n*sensitivity*\n  The sensitivity weight on the variance.\n\n*lower bound*\n  A global threshold beneath which all pixels are considered black.\n\n*upper bound*\n  A global threshold above which all pixels are considered white.\"", "settings": "[{\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region size\", \"type\": \"int\"}, {\"default\": \"-0.2\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"sensitivity\", \"type\": \"real\"}, {\"default\": 20, \"has_default\": true, \"rng\": [0, 255], \"name\": \"lower bound\", \"type\": \"int\"}, {\"default\": 150, \"has_default\": true, \"rng\": [0, 255], \"name\": \"upper bound\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.plugins.binarization.niblack_threshold", "interactive": false}, "model": "rodan.job", "pk": "b4dcb14a57d945daa79fb6bdf18a9af6"}, {"fields": {"category": "Background Estimation", "description": "\"**wiener2_filter** (int *region_width* = 5, int *region_height* = 5, float *noise_variance* = -1.00)\n\nAdaptive directional filtering\n\n*region_width*, *region_height*\n  The size of the region within which to calculate the intermediate pixel value.\n\n*noise_variancee*\n  noise variance. If negative, estimated automatically.\"", "settings": "[{\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region_width\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region_height\", \"type\": \"int\"}, {\"default\": \"-1.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"noise_variance\", \"type\": \"real\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.background_estimation.plugins.background_estimation.wiener2_filter", "interactive": false}, "model": "rodan.job", "pk": "b4e4ad0576394193978df8fa228f6c7c"}, {"fields": {"category": "Border Removal", "description": "TO DO", "settings": "[{\"has_default\": true, \"name\": \"image_width\", \"default\": 0, \"rng\": [-1048576, 1048576], \"visibility\": false, \"type\": \"int\"}, {\"default\": null, \"has_default\": true, \"type\": \"json\", \"name\": \"polygon_outer_points\", \"visibility\": false}]", "author": "Deepanjan Roy", "enabled": true, "job_name": "gamera.custom.border_removal.poly_mask", "interactive": true}, "model": "rodan.job", "pk": "b80068ad16e4419881699108629bf7b4"}, {"fields": {"category": "Binarization", "description": "\"**threshold** (int *threshold*, ``Choice`` [dense|rle] *storage format*)\n\nCreates a binary image by splitting along a given global threshold value.\n\nPixels that are greater than the given value become white.\nPixels less than or equal to the given value become black.\n\n*storage_format* (optional)\n  specifies the compression type for the result:\n\n  DENSE (0)\n    no compression\n  RLE (1)\n    run-length encoding compression.\"", "settings": "[{\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"threshold\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"type\": \"choice\", \"name\": \"storage format\", \"choices\": [\"dense\", \"rle\"]}]", "author": null, "enabled": true, "job_name": "gamera.plugins.threshold.threshold", "interactive": false}, "model": "rodan.job", "pk": "bbee018baecb407c8df6baeaa3f41143"}, {"fields": {"category": "Binarization", "description": "\"**variance_filter** (``Image`` [Float] *means*, int *region size* = 5)\n\nReturns the regional variance of an image as a FLOAT.\n\n*means*\n  Pre-calculated means for each region.\n\n*region_size*\n  The size of the region in which to calculate the variance.\"", "settings": "[{\"has_default\": false, \"name\": \"means\", \"default\": null, \"list_of\": false, \"pixel_types\": [4], \"type\": \"imagetype\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region size\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.plugins.binarization.variance_filter", "interactive": false}, "model": "rodan.job", "pk": "be05649dbc3247e2b7c905737b29631f"}, {"fields": {"category": "Border Removal", "description": "\"**paper_estimation** (int *sign* = 1, int *dil_win* = 3, int *avg_win* = 5, int *med_win* = 5)\n\nReturns the estimation of background paper by removing foreground pen strokes.\n\nNote: the default parameter works on image with standard area 114000 (rows*cols)\n\nMain process: filling hols -> mean filter -> median filter\n\n*sign*\n    An extra smoothing process(dilation+erosion) is applied at the begining, when sign=1.\n    An extra edge-preserving process(filling holes) is applied at the end, when sign=0.\n\n*dil_win*\n    region size for dilation+erosion.\n\n*avg_win*\n    region size for mean filter.\n\n*med_win*\n    region size for median filter.\"", "settings": "[{\"default\": 1, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"sign\", \"type\": \"int\"}, {\"default\": 3, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"dil_win\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"avg_win\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"med_win\", \"type\": \"int\"}]", "author": "Yue Phyllis Ouyang and John Ashley Burgoyne", "enabled": true, "job_name": "gamera.toolkits.border_removal.plugins.border_removal.paper_estimation", "interactive": false}, "model": "rodan.job", "pk": "ca770d9a9c2b453fb267bae3fa2d6a6e"}, {"fields": {"category": "Background Estimation", "description": "\"**gatos_threshold_mask** (``Image`` [GreyScale] *background*, ``Image`` [OneBit] *binarization*, ``Image`` [OneBit] *mask*, float *q* = 0.60, float *p1* = 0.50, float *p2* = 0.80)\n\nThresholds an image according to Gatos et al.'s method. See:\n\nGatos, Basilios, Ioannis Pratikakis, and Stavros\nJ. Perantonis. 2004. An adaptive binarization technique for low\nquality historical documents. *Lecture Notes in Computer\nScience* 3163: 102-113.\n\nThis version adds masking process. Only regions within the mask are binarized, the rest is filled with white color\n\n*background*\n  Estimated background of the image.\n\n*binarization*\n  A preliminary binarization of the image.\n\n*mask*\n  Mask image that defines the process region\n\nUse the default settings for the other parameters unless you know\nwhat you are doing.\"", "settings": "[{\"has_default\": false, \"name\": \"background\", \"default\": null, \"list_of\": false, \"pixel_types\": [1], \"type\": \"imagetype\"}, {\"has_default\": false, \"name\": \"binarization\", \"default\": null, \"list_of\": false, \"pixel_types\": [0], \"type\": \"imagetype\"}, {\"has_default\": false, \"name\": \"mask\", \"default\": null, \"list_of\": false, \"pixel_types\": [0], \"type\": \"imagetype\"}, {\"default\": \"0.6\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"q\", \"type\": \"real\"}, {\"default\": \"0.5\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"p1\", \"type\": \"real\"}, {\"default\": \"0.8\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"p2\", \"type\": \"real\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.background_estimation.plugins.background_estimation.gatos_threshold_mask", "interactive": false}, "model": "rodan.job", "pk": "ce27d3f3035541ff828e40ac1f724013"}, {"fields": {"category": "Border Removal", "description": "\"**edge_detection** (``Image`` [GreyScale] *image2*, float *threshold1_scale* = 0.80, float *threshold1_gradient* = 6.00, float *threshold2_scale* = 0.80, float *threshold2_gradient* = 6.00, float *tranfer_parameter* = 0.25)\n\nDetects and combines edges from two images in different levels of smoothness.\n\n*image2*\n    the image of same subject as current image, but in lower level of smoothness.\n    (the result of \"paper_estimation\" with sign=0)\n\n*threshold1_scale*\n    scale for canny edge detector on current image. See Edge->canny_edge_image for details.\n\n*threshold1_gradient*\n    gradient for canny edge detector on current image. See Edge->canny_edge_image for details.\n\n*threshold2_scale*\n    scale for canny edge detector on image2. See Edge->canny_edge_image for details.\n\n*threshold2_gradient*\n    gradient for canny edge detector on image2. See Edge->canny_edge_image for details.\n\n*transfer_para*\n    edge tranfer parameter.\n    Ther higher it is, the more edges in image2 will be combined into final edge map.\"", "settings": "[{\"has_default\": false, \"name\": \"image2\", \"default\": null, \"list_of\": false, \"pixel_types\": [1], \"type\": \"imagetype\"}, {\"default\": \"0.8\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold1_scale\", \"type\": \"real\"}, {\"default\": \"6.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold1_gradient\", \"type\": \"real\"}, {\"default\": \"0.8\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold2_scale\", \"type\": \"real\"}, {\"default\": \"6.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold2_gradient\", \"type\": \"real\"}, {\"default\": \"0.25\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"tranfer_parameter\", \"type\": \"real\"}]", "author": "Yue Phyllis Ouyang and John Ashley Burgoyne", "enabled": true, "job_name": "gamera.toolkits.border_removal.plugins.border_removal.edge_detection", "interactive": false}, "model": "rodan.job", "pk": "cf0e6ee7b75e4844a698fc969fd70bf4"}, {"fields": {"category": "Border Removal", "description": "\"**boundary_reconstruct** (int *terminate_time1* = 15, int *terminate_time2* = 23, int *terminate_time3* = 75, int *interval2* = 45, int *interval3* = 15)\n\nReconstructs boundary of music score based on edge map from edg_detection.\n\n*terminate_time1*\n    maximum numbers of iterations in 1st round.\n\n*terminate_time2*\n    maximum numbers of iterations in 2nd round.\n\n*terminate_time3*\n    maximum numbers of iterations in 3rd round.\n\n*interval2*\n    interval for edge adding in 2nd round.\n\n*interval3*\n    interval for edge adding in 3rd round.\"", "settings": "[{\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"terminate_time1\", \"type\": \"int\"}, {\"default\": 23, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"terminate_time2\", \"type\": \"int\"}, {\"default\": 75, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"terminate_time3\", \"type\": \"int\"}, {\"default\": 45, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"interval2\", \"type\": \"int\"}, {\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"interval3\", \"type\": \"int\"}]", "author": "Yue Phyllis Ouyang and John Ashley Burgoyne", "enabled": true, "job_name": "gamera.toolkits.border_removal.plugins.border_removal.boundary_reconstruct", "interactive": false}, "model": "rodan.job", "pk": "d348bc57adc14b97b152635797b882c5"}, {"fields": {"category": "Despeckling", "description": "\"**rdn_despeckle** (int(1, 100) *cc_size*, int *image_width*)\n\nA thin wrapper around despeckle() to get the\ndesired despeckling behaviour for Rodan.\n\nDesired behaviour involves returning a gamera Image, rather\njust applying it to the image that is passed in and returning nothingm,\nand also scaling the cc_size, although I'm (Deepanjan) not sure if this works.\"", "settings": "[{\"default\": 0, \"has_default\": false, \"rng\": [1, 100], \"name\": \"cc_size\", \"type\": \"int\"}, {\"default\": 0, \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"image_width\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.rodan_plugins.plugins.rdn_despeckle.rdn_despeckle", "interactive": false}, "model": "rodan.job", "pk": "dd7d865e60ab4ec4b6cadaa0e8e13a38"}, {"fields": {"category": "Border and Lyric Extraction", "description": "\"**lyricline_extraction** (``Image`` [OneBit] *binarization*)\n\nRemoves stafflines and extract lyriclines.\n        Note: no post-processing to extract precise posistion of each lyric or deal with overlapping situation is applied.\n       *binarization*\n         image after border removal and binarization\n       For best performance, scale the image around 1000*1000 to 2000*2000\n    \"", "settings": "[{\"has_default\": false, \"name\": \"binarization\", \"default\": null, \"list_of\": false, \"pixel_types\": [0], \"type\": \"imagetype\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.lyric_extraction.plugins.border_lyric.lyricline_extraction", "interactive": false}, "model": "rodan.job", "pk": "de85ed1080b348709b8f77da28b25a14"}, {"fields": {"category": "Binarization", "description": "\"**bernsen_threshold** (``Choice`` [dense|rle] *storage format*, int(1, 50) *region size* = 11, int(0, 255) *contrast limit* = 80, ``bool`` *doubt_to_black* = False)\n\nCreates a binary image by using the Bernsen algorithm.\n\nEach point is thresholded by the mean between the maximum and minimum\nvalue in the surrounding region of size *region_size*. When the difference\nbetween maximum and minimum is below *contrast_limit* the pixel is set\nto black in case of *doubt_to_black* = ``True``, otherwise to white.\n\nReference: J. Bernsen: *Dynamic thresholding of grey-level images.* \nProc. 8th International Conference on Pattern Recognition (ICPR8),\npp. 1251-1255, 1986.\n\n*storage_format*\n  specifies the compression type for the result:\n\n  DENSE (0)\n    no compression\n  RLE (1)\n    run-length encoding compression\n\n*region_size*\n  The size of each region in which to calculate a threshold\n\n*contrast_limit*\n  The minimum amount of contrast required to threshold.\n\n*doubt_to_black*\n  When ``True``, 'doubtful' values are set to black, otherwise to white.\"", "settings": "[{\"default\": 0, \"has_default\": false, \"type\": \"choice\", \"name\": \"storage format\", \"choices\": [\"dense\", \"rle\"]}, {\"default\": 11, \"has_default\": true, \"rng\": [1, 50], \"name\": \"region size\", \"type\": \"int\"}, {\"default\": 80, \"has_default\": true, \"rng\": [0, 255], \"name\": \"contrast limit\", \"type\": \"int\"}, {\"has_default\": true, \"name\": \"doubt_to_black\", \"default\": false, \"enabled\": true, \"type\": \"check\", \"check_box\": \"\"}]", "author": null, "enabled": true, "job_name": "gamera.plugins.threshold.bernsen_threshold", "interactive": false}, "model": "rodan.job", "pk": "dff6c2f0c925499aa8b680dfbc6f9252"}, {"fields": {"category": "Transformation", "description": "\"**scale** (float *scaling*, ``Choice`` [None|Linear|Spline] *interp_type*)\n\nReturns a scaled copy of the image. In addition to scale, the type\nof interpolation can be specified, with a tradeoff between speed\nand quality.\n\nIf you need to change the aspect ratio of the original image,\nconsider using resize_ instead.\n\n*scale*\n  A scaling factor.  Values greater than 1 will result in a larger image.\n  Values less than 1 will result in a smaller image.\n\n*interp_type* [None|Linear|Spline]\n  The type of interpolation used to resize the image.  Each option is\n  progressively higher quality, yet slower.\n\n.. _resize: #resize\"", "settings": "[{\"default\": \"0.0\", \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"scaling\", \"type\": \"real\"}, {\"default\": 0, \"has_default\": false, \"type\": \"choice\", \"name\": \"interp_type\", \"choices\": [\"None\", \"Linear\", \"Spline\"]}]", "author": null, "enabled": true, "job_name": "gamera.plugins.transformation.scale", "interactive": false}, "model": "rodan.job", "pk": "e2eb275c9f684adf91657b74c023bce0"}, {"fields": {"category": "Lyric Line Extraction", "description": "\"**lyric_line_detection** (float *staffspace*, int *threshold_noise* = 15, float *scalar_cc_strip* = 1.00, float *seg_angle_degree* = 30.00, float *scalar_seg_dist* = 3.50, int *min_group* = 4, float *merge_angle_degree* = 5.00, float *scalar_merge_dist* = 5.00, float *valid_angle_degree* = 20.00, float *scalar_valid_height* = 1.00, int *valid_min_group* = 8, float *scalar_height* = 3.00, float *fit_angle_degree* = 2.50, float *scalar_search_height* = 1.20, float *scalar_fit_up* = 1.20, float *scalar_fit_down* = 0.30)\n\nReturns the mask of lyric lines.\n\nGathers baseline_detection, lyric_height_estimation and lyric_line_fit functions.\n\nNote: no post-processing to extract precise posistion of each lyric or deal with overlapping situation is applied.\"", "settings": "[{\"default\": \"0.0\", \"has_default\": false, \"rng\": [-1048576, 1048576], \"name\": \"staffspace\", \"type\": \"real\"}, {\"default\": 15, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"threshold_noise\", \"type\": \"int\"}, {\"default\": \"1.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_cc_strip\", \"type\": \"real\"}, {\"default\": \"30.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"seg_angle_degree\", \"type\": \"real\"}, {\"default\": \"3.5\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_seg_dist\", \"type\": \"real\"}, {\"default\": 4, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"min_group\", \"type\": \"int\"}, {\"default\": \"5.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"merge_angle_degree\", \"type\": \"real\"}, {\"default\": \"5.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_merge_dist\", \"type\": \"real\"}, {\"default\": \"20.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"valid_angle_degree\", \"type\": \"real\"}, {\"default\": \"1.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_valid_height\", \"type\": \"real\"}, {\"default\": 8, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"valid_min_group\", \"type\": \"int\"}, {\"default\": \"3.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_height\", \"type\": \"real\"}, {\"default\": \"2.5\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"fit_angle_degree\", \"type\": \"real\"}, {\"default\": \"1.2\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_search_height\", \"type\": \"real\"}, {\"default\": \"1.2\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_fit_up\", \"type\": \"real\"}, {\"default\": \"0.3\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scalar_fit_down\", \"type\": \"real\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.lyric_extraction.plugins.lyricline.lyric_line_detection", "interactive": false}, "model": "rodan.job", "pk": "e3defb4a4c3c47e094b1a1ce5dbad313"}, {"fields": {"category": "Conversion", "description": "\"**to_grey16** ()\n\nConverts the given image to a GREY16 image according to the\nfollowing rules:\n\n- for ONEBIT images, 0 is mapped to 65535 and everything else to 0.\n- for FLOAT images, the range [min,max] is linearly scaled to [0,65535]\n- for GREYSCALE images, pixel values are copied unchanged\n- for RGB images, the luminance is used, which is defined in VIGRA as 0.3*R + 0.59*G + 0.11*B. This results only in a value range [0,255]\n\nConverting an image to one of the same type performs a copy operation.\"", "settings": "[]", "author": "Michael Droettboom, Karl MacMillan, and Christoph Dalitz", "enabled": true, "job_name": "gamera.plugins.image_conversion.to_grey16", "interactive": false}, "model": "rodan.job", "pk": "e4b37501bfbc40db93e20f3649cd5ec4"}, {"fields": {"category": "Binarization", "description": "\"**tsai_moment_preserving_threshold** (``Choice`` [dense|rle] *storage format*)\n\nCreates a binary image by splitting along a threshold value\ndetermined using the Tsai Moment Preserving Threshold algorithm.\n\nEquivalent to\n``image.threshold(image.tsai_moment_preserving_find_threshold())``.\n\n*storage_format* (optional)\n  specifies the compression type for the result:\n\n  DENSE (0)\n    no compression\n  RLE (1)\n    run-length encoding compression\"", "settings": "[{\"default\": 0, \"has_default\": false, \"type\": \"choice\", \"name\": \"storage format\", \"choices\": [\"dense\", \"rle\"]}]", "author": "Uma Kompella", "enabled": true, "job_name": "gamera.plugins.threshold.tsai_moment_preserving_threshold", "interactive": false}, "model": "rodan.job", "pk": "e773f75024844e5baa13788870d489a5"}, {"fields": {"category": "Binarization", "description": "\"**wiener_filter** (int *region size* = 5, float *noise variance* = -1.00)\n\nAdaptive Wiener filter for de-noising.\n\nSee:\n\nJ. Lim. 2001. *Two-Dimensional Signal Processing.* Englewood\nCliffs: Prentice Hall.\n\n*region_size*\n  The size of the region within which to calculate the filter\n  coefficients.\n\n*noise_variance* \n  Variance of the noise in the image. If negative, estimated\n  automatically as the median of local variances.\"", "settings": "[{\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region size\", \"type\": \"int\"}, {\"default\": \"-1.0\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"noise variance\", \"type\": \"real\"}]", "author": null, "enabled": true, "job_name": "gamera.plugins.binarization.wiener_filter", "interactive": false}, "model": "rodan.job", "pk": "ec2a83e3b7ef48919a83b1aab43d171f"}, {"fields": {"category": "Binarization", "description": "\"**gatos_threshold** (``Image`` [GreyScale] *background*, ``Image`` [OneBit] *binarization*, float *q* = 0.60, float *p1* = 0.50, float *p2* = 0.80)\n\nThresholds an image according to Gatos et al.'s method. See:\n\nGatos, Basilios, Ioannis Pratikakis, and Stavros\nJ. Perantonis. 2004. An adaptive binarization technique for low\nquality historical documents. *Lecture Notes in Computer\nScience* 3163: 102-113.\n\n*background*\n  Estimated background of the image.\n\n*binarization*\n  A preliminary binarization of the image.\n\nUse the default settings for the other parameters unless you know\nwhat you are doing.\"", "settings": "[{\"has_default\": false, \"name\": \"background\", \"default\": null, \"list_of\": false, \"pixel_types\": [1], \"type\": \"imagetype\"}, {\"has_default\": false, \"name\": \"binarization\", \"default\": null, \"list_of\": false, \"pixel_types\": [0], \"type\": \"imagetype\"}, {\"default\": \"0.6\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"q\", \"type\": \"real\"}, {\"default\": \"0.5\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"p1\", \"type\": \"real\"}, {\"default\": \"0.8\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"p2\", \"type\": \"real\"}]", "author": null, "enabled": true, "job_name": "gamera.plugins.binarization.gatos_threshold", "interactive": false}, "model": "rodan.job", "pk": "ece3fb4902ad402286f43c3db4336618"}, {"fields": {"category": "Border and Lyric Extraction", "description": "\"**segment_by_colour** (int *minimum_y_threshold* = 10, int *num_searches* = 4, int *negative_bound* = 10, int *postive_bound* = 10)\n\nSame as extract_lyrics, only the lyrics and neumes are highlighted by the specified colours (neums: red, text: black).\n\nParameters:\n\n  minimum_y_threshold: the minimum value that may be considered a local peak\n  in the horizontal projection.\n\n  num_searches: the number of searches to do around each local peak\n\n  negative_bound: how far below the local peak to start the line search (this\n  value is positive! so the value of negative_bound=10 will start searching 10\n  pixels below the peak-point (or -10 pixels. To make this even more\n  confusing, the negative direction is actually upward when talking about\n  images, but you already knew this from reading the Gamera documentation).\n\n  positive_bound: how far above the local peak to start the line search\n\n  delta: see the delta parameter for the peakdet function above\"", "settings": "[{\"default\": 10, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"minimum_y_threshold\", \"type\": \"int\"}, {\"default\": 4, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"num_searches\", \"type\": \"int\"}, {\"default\": 10, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"negative_bound\", \"type\": \"int\"}, {\"default\": 10, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"postive_bound\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.toolkits.lyric_extraction.plugins.lyric_extractor.segment_by_colour", "interactive": false}, "model": "rodan.job", "pk": "f5db993e42314dcc8a0c251d8d0c6e58"}, {"fields": {"category": "Segmentation", "description": "Finds the staves using Miyao Staff Finder and masks out everything else.", "settings": "[{\"default\": 0, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"num lines\", \"type\": \"int\"}, {\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"scanlines\", \"type\": \"int\"}, {\"default\": \"0.8\", \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"blackness\", \"type\": \"real\"}, {\"default\": -1, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"tolerance\", \"type\": \"int\"}, {\"default\": null, \"has_default\": true, \"type\": \"json\", \"name\": \"polygon_outer_points\"}, {\"default\": 0, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"image_width\", \"type\": \"int\"}]", "author": "Deepanjan Roy", "enabled": true, "job_name": "gamera.custom.segmentation.segmentation", "interactive": true}, "model": "rodan.job", "pk": "f7ad01d70f364e10b86d05e8faa8d20e"}, {"fields": {"category": "Binarization", "description": "\"**mean_filter** (int *region size* = 5)\n\nReturns the regional mean of an image as a FLOAT.\n\n*region_size*\n  The size of the region in which to calculate a mean.\"", "settings": "[{\"default\": 5, \"has_default\": true, \"rng\": [-1048576, 1048576], \"name\": \"region size\", \"type\": \"int\"}]", "author": null, "enabled": true, "job_name": "gamera.plugins.binarization.mean_filter", "interactive": false}, "model": "rodan.job", "pk": "f8450d460f98442f8d20764b3f57fb7f"}, {"fields": {"category": "Conversion", "description": "\"**to_float** ()\n\nConverts the given image to a FLOAT image according to the following\nrules:\n\n- for ONEBIT images, 0 is mapped to 0.0 and everything else to 1.0\n- for GREYSCALE and GREY16 images, pixel values are copied unchanged\n- for RGB images, the luminance is used, which is defined in VIGRA as 0.3*R + 0.59*G + 0.11*B\n\nConverting an image to one of the same type performs a copy operation.\"", "settings": "[]", "author": null, "enabled": true, "job_name": "gamera.plugins.image_conversion.to_float", "interactive": false}, "model": "rodan.job", "pk": "f948237bd4bf4aff882e7638a390564a"}, {"fields": {"category": "Binarization", "description": "\"**brink_threshold** ()\n\nCalculates threshold for image with Brink and Pendock's minimum-cross    \nentropy method and returns corrected image. It is best used for binarising\nimages with dark, near-black foreground and significant bleed-through.\nTo that end, it generally predicts lower thresholds than other\nthresholding algorithms.\n\nReference: A.D. Brink, N.E. Pendock: Minimum cross-entropy threshold selection.\nPattern Recognition 29 (1), 1996. 179-188.\"", "settings": "[]", "author": "Johanna Devaney, Brian Stern", "enabled": true, "job_name": "gamera.plugins.binarization.brink_threshold", "interactive": false}, "model": "rodan.job", "pk": "fc782d1cc1be48d1848875234f216bb9"}]